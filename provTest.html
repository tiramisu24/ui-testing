<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: Helvetica;
}

.update {
  color: #888888;
  position:absolute;
  top: 10px;
  left: 10px;
  padding: 5px 10px;
  margin: 10px;
  cursor: pointer;
  border: 1px solid #999999;
  border-radius: 3px;
}

.node circle {
  fill: #888888;
  stroke: #fff;
  stroke-width: 2px;
}

.node text {
  fill: #888888;
  stroke: none;
  font-size: .6em;
}

.link {
  stroke: #cccccc;
  stroke-opacity: .6;
}

</style>
<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var width = 400,
    height = 400,
    radius = 10,
    oldNodes, // data
    svg, node, link, // d3 selections
    force = d3.layout.force()
    .charge(-300)
    .linkDistance(50)
    .size([width, height]);

var a = { node:0, name:"test0", info: [], nodeType: "core", objId: 1},
    b = { node:1, name:"test1", info: [], nodeType: "core", objId: 12},
    c = { node:2, name:"test2", info: [], nodeType: "core", objId: 123},
    e = { node:3, name:"test3", info: [], nodeType: "core", objId: 1234},
    f = { node:4, name:"test4", info: [], nodeType: "core", objId: 12345},
    nodes = [a, b, c],
    links = [{source: a, target: b},
            {source: a, target: 2}];

// function randomData() {
//   oldNodes = nodes;
//   // generate some data randomly
//   nodes = _.chain(_.range(_.random(10, 20)))
//     .map(function() {
//       var node = {};
//       node.key = _.random(0, 30);
//       node.weight = _.random(4, 10);
//
//       return node;
//     }).uniq(function(node) {
//       return node.key
//     }).value();
//
//   if (oldNodes) {
//     var add = _.initial(oldNodes, _.random(0, oldNodes.length));
//     add = _.rest(add, _.random(0, add.length));
//
//     nodes = _.union(nodes, add);
//   }
//
//   links = _.map(_.range(_.random(15, 25)), function() {
//       var link = {};
//       link.source = _.random(0, nodes.length - 1);
//       link.target = _.random(0, nodes.length - 1);
//       link.weight = _.random(1, 3);
//
//       return link;
//     });
//     debugger;
//   maintainNodePositions();
//
// }

function render() {
  // randomData();
  force.nodes(nodes)
        .links(links)
        .on("tick", tick);

  svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

  var l = svg.selectAll(".link")
    .data(links, function(d) {return d.source + "," + d.target});
  var n = svg.selectAll(".node")
    .data(nodes, function(d) {return d.name});
  enterLinks(l);
  enterNodes(n);

  link = svg.selectAll(".link");
  node = svg.selectAll(".node");

  force.start();
  for (var i = 100; i > 0; --i) force.tick();
  force.stop();
}

function update() {
  oldNodes = nodes;
  maintainNodePositions();

  nodes.push(e);
  nodes.push(f);
  links.push({source: 2, target: 3});
  links.push({source: 2, target: 4});

  force.nodes(nodes).links(links);

  var l = svg.selectAll(".link")
    .data(links, function(d) {return d.source + "," + d.target});
  var n = svg.selectAll(".node")
    .data(nodes, function(d) {return d.name});
  enterLinks(l);
  //add different selector
  // exitLinks(l);
  enterNodes(n);
  exitNodes(n);
  link = svg.selectAll(".link");
  node = svg.selectAll(".node");

  // link.style("stroke-width", function(d) { return d.weight; });

  node.select("circle").attr("r", 10);
  force.start();
  for (var i = 100; i > 0; --i) force.tick();
  force.stop();
}
var drag = force.drag()
    .on("dragstart", dragstart)
    .on("dragend", dragstop);
function dragstart(d) {
    d.fixed = true;
    force.stop();
    // d3.select(this).classed("fixed", d.fixed = true);
}
function dragstop(d){
  d.fixed = true;
  force.stop();
}
function enterNodes(n) {
  var g = n.enter().append("g")
    .attr("class", "node")
    .call(force.drag);
    // .call(function(node) { node.transition().attr("r", 8); });

  g.append("circle")
    .attr("cx", 0)
    .attr("cy", 0)
    .attr("r", radius)
    .style("fill", "pink");
    // .call(force.drag);

  g.append("text")
    .attr("dy", "1.5em")
    .attr("dx", ".5em")
    .text(function(d) {return d.name});
}

function exitNodes(n) {
  n.exit().remove();
}

function enterLinks(l) {
  l.enter().insert("line", ".node")
    .attr("class", "link")
    .attr("id", function(d){return d.source.objId + "," +  d.target.objId;})
    .on('click', linkClick)
    .style("stroke-width", function(d) { return 10; });
}

function exitLinks(l) {
  l.exit().remove();
}

function maintainNodePositions() {
  var kv = {};
  oldNodes.forEach( function(d) {
    d.fixed = true;
    kv[d.name] = d;
  });
  // _.each(nodes, function(d) {
  //   if (kv[d.name]) {
  //     // if the node already exists, maintain current position
  //     d.x = kv[d.name].x;
  //     d.y = kv[d.name].y;
  //   } else {
  //     // else assign it a random position near the center
  //     d.x = width / 2 + _.random(-150, 150);
  //     d.y = height / 2 + _.random(-25, 25);
  //   }
  // });
}

 function tick(e) {
  var k = 10 * e.alpha;

  node.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
      .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); })
    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
  // Push sources up and targets down to form a weak tree.
  link
      .each(function(d) {d.source.y += k, d.target.y -= k; })
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

};
function linkClick(link){
  // debugger;
    // link.classed('remove',true);
  // d3.select(this).classed("remove",true);
  // d3.select(link.target).classed("remove",true);
  // link.target.attr('class', 'remove-link');
  // debugger;
  //TODO: tree prune
}


render();

</script>

<div class="update" onClick="update()">update</update>

</body>
