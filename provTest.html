<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font-family: Helvetica;
}

.update {
  color: #888888;
  position:absolute;
  top: 10px;
  left: 10px;
  padding: 5px 10px;
  margin: 10px;
  cursor: pointer;
  border: 1px solid #999999;
  border-radius: 3px;
}

.node circle {
  fill: #888888;
  stroke: #fff;
  stroke-width: 2px;
}

.node text {
  fill: #888888;
  stroke: none;
  font-size: .6em;
}

.link {
  stroke: #cccccc;
  stroke-opacity: .6;
}

</style>
<body>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://underscorejs.org/underscore-min.js"></script>
<script>

var width = 400,
    height = 400,
    oldNodes, // data
    svg, node, link, // d3 selections
    force = d3.layout.force()
    .charge(-300)
    .linkDistance(50)
    .size([width, height]);

var a = { node:0, name:"test0", info: [], nodeType: "core", objId: 1},
    b = { node:1, name:"test1", info: [], nodeType: "core", objId: 12},
    c = { node:2, name:"test2", info: [], nodeType: "core", objId: 123},
    e = { node:3, name:"test3", info: [], nodeType: "core", objId: 1234},
    f = { node:4, name:"test4", info: [], nodeType: "core", objId: 12345},
    nodes = [a, b, c],
    links = [{source: 0, target: 1},
            {source: 0, target: 2}];

function randomData() {
  oldNodes = nodes;
  // generate some data randomly
  nodes = _.chain(_.range(_.random(10, 20)))
    .map(function() {
      var node = {};
      node.key = _.random(0, 30);
      node.weight = _.random(4, 10);

      return node;
    }).uniq(function(node) {
      return node.key
    }).value();

  if (oldNodes) {
    var add = _.initial(oldNodes, _.random(0, oldNodes.length));
    add = _.rest(add, _.random(0, add.length));

    nodes = _.union(nodes, add);
  }

  links = _.map(_.range(_.random(15, 25)), function() {
      var link = {};
      link.source = _.random(0, nodes.length - 1);
      link.target = _.random(0, nodes.length - 1);
      link.weight = _.random(1, 3);

      return link;
    });
    debugger;
  maintainNodePositions();

}

function render() {
  // randomData();
  force.nodes(nodes).links(links);

  svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

  var l = svg.selectAll(".link")
    .data(links, function(d) {return d.source + "," + d.target});
  var n = svg.selectAll(".node")
    .data(nodes, function(d) {return d.name});
  enterLinks(l);
  enterNodes(n);

  link = svg.selectAll(".link");
  node = svg.selectAll(".node");

  force.start();
}

function update() {
  oldNodes = nodes;

  nodes.push(e);
  nodes.push(f);
  links.push({source: 2, target: 3});
  links.push({source: 3, target: 4});
  maintainNodePositions();
  // debugger;
  // randomData();
  force.nodes(nodes).links(links);

  var l = svg.selectAll(".link")
    .data(links, function(d) {return d.source + "," + d.target});
  var n = svg.selectAll(".node")
    .data(nodes, function(d) {return d.name});
  enterLinks(l);
  // exitLinks(l);
  enterNodes(n);
  exitNodes(n);
  link = svg.selectAll(".link");
  node = svg.selectAll(".node");

  // link.style("stroke-width", function(d) { return d.weight; });

  node.select("circle").attr("r", 1);

  force.start();
}

function enterNodes(n) {
  var g = n.enter().append("g")
    .attr("class", "node");

  g.append("circle")
    .attr("cx", 0)
    .attr("cy", 0)
    .attr("r", 1)
    .call(force.drag);

  g.append("text")
    .attr("dy", ".35em")
    .text(function(d) {return d.name});
}

function exitNodes(n) {
  n.exit().remove();
}

function enterLinks(l) {
  l.enter().insert("line", ".node")
    .attr("class", "link")
    .style("stroke-width", function(d) { return d.weight; });
}

function exitLinks(l) {
  l.exit().remove();
}

function maintainNodePositions() {
  var kv = {};
  _.each(oldNodes, function(d) {
    // debugger;
    kv[d.name] = d;
  });
  _.each(nodes, function(d) {
    if (kv[d.name]) {
      // if the node already exists, maintain current position
      d.x = kv[d.name].x;
      d.y = kv[d.name].y;
    } else {
      // else assign it a random position near the center
      d.x = width / 2 + _.random(-150, 150);
      d.y = height / 2 + _.random(-25, 25);
    }
  });
}

force.on("tick", function(e) {
  var k = 6 * e.alpha;
  // Push sources up and targets down to form a weak tree.
  link
      .each(function(d) {d.source.y -= k, d.target.y += k; })
      .attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });
});



render();

</script>

<div class="update" onClick="update()">update</update>

</body>
